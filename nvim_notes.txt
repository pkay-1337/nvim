All commands in : index.txt

Lua :

	Vim commands                                            *lua-guide-vim-commands*

		To run an arbitrary Vim command from Lua, pass it as a string to |vim.cmd()|:
		>lua
			vim.cmd("colorscheme habamax")
		<

		If you want to build your Vim command programmatically, the following form can
		be useful (all these are equivalent to the corresponding line above):
		>lua
			vim.cmd.colorscheme("habamax")
			vim.cmd.highlight({ "Error", "guibg=red" })
			vim.cmd.highlight({ "link", "Warning", "Error" })


	Vimscript functions                                    *lua-guide-vim-functions*

		Use |vim.fn| to call Vimscript functions from Lua. Data types between Lua and
		Vimscript are automatically converted:
		>lua
			print(vim.fn.printf('Hello from %s', 'Lua'))

	Variables                                                  *lua-guide-variables*

		Variables can be set and read using the following wrappers, which directly
		correspond to their |variable-scope|:

		• |vim.g|:   global variables (|g:|)
		• |vim.b|:   variables for the current buffer (|b:|)
		• |vim.w|:   variables for the current window (|w:|)
		• |vim.t|:   variables for the current tabpage (|t:|)
		• |vim.v|:   predefined Vim variables (|v:|)
		• |vim.env|: environment variables defined in the editor session

		Data types are converted automatically. For example:
		>lua
			vim.g.some_global_variable = {
			  key1 = "value",
			  key2 = 300
			}

			vim.print(vim.g.some_global_variable)
			--> { key1 = "value", key2 = 300 }
		<
		You can target specific buffers (via number), windows (via |window-ID|), or
		tabpages by indexing the wrappers:
		>lua
			vim.b[2].myvar = 1               -- set myvar for buffer number 2
			vim.w[1005].myothervar = true    -- set myothervar for window ID 1005

		To delete a variable, simply set it to `nil`:
		>lua
			vim.g.myvar = nil


	vim.opt

		The most convenient way for setting global and local options, e.g., in `init.lua`,
		is through `vim.opt` and friends:

		• |vim.opt|:        behaves like |:set|
		• |vim.opt_global|: behaves like |:setglobal|
		• |vim.opt_local|:  behaves like |:setlocal|


	vim.o

		For this reason, there exists a more direct variable-like access using `vim.o`
		and friends, similarly to how you can get and set options via `:echo &number`
		and `:let &listchars='space:_,tab:>~'`:

		• |vim.o|:  behaves like |:set|
		• |vim.go|: behaves like |:setglobal|
		• |vim.bo|: for buffer-scoped options
		• |vim.wo|: for window-scoped options (can be double indexed)

		Just like variables, you can specify a buffer number or |window-ID| for buffer
		and window options, respectively. If no number is given, the current buffer or
		window is used:
		>lua
			vim.bo[4].expandtab = true -- sets expandtab to true in buffer 4
			vim.wo.number = true       -- sets number to true in current window
			vim.wo[0].number = true    -- same as above
			vim.wo[0][0].number = true -- sets number to true in current buffer
									   -- in current window only
			print(vim.wo[0].number)    --> true


	Creating mappings                                       *lua-guide-mappings-set*

		Mappings can be created using |vim.keymap.set()|. This function takes three
		mandatory arguments:
		• {mode} is a string or a table of strings containing the mode
		  prefix for which the mapping will take effect. The prefixes are the ones
		  listed in |:map-modes|, or "!" for |:map!|, or empty string for |:map|.
		• {lhs} is a string with the key sequences that should trigger the mapping.
		• {rhs} is either a string with a Vim command or a Lua function that should
		  be executed when the {lhs} is entered.
		  An empty string is equivalent to |<Nop>|, which disables a key.

		Examples:
		>lua
			-- Normal mode mapping for Vim command
			vim.keymap.set('n', '<Leader>ex1', '<cmd>echo "Example 1"<cr>')
			-- Normal and Command-line mode mapping for Vim command
			vim.keymap.set({'n', 'c'}, '<Leader>ex2', '<cmd>echo "Example 2"<cr>')
			-- Normal mode mapping for Lua function
			vim.keymap.set('n', '<Leader>ex3', vim.treesitter.start)
			-- Normal mode mapping for Lua function with arguments
			vim.keymap.set('n', '<Leader>ex4', function() print('Example 4') end)


		The fourth, optional, argument is a table with keys that modify the behavior
		of the mapping such as those from |:map-arguments|. The following are the most
		useful options:
		• `buffer`: If given, only set the mapping for the buffer with the specified
		  number; `0` or `true` means the current buffer. >lua
			-- set mapping for the current buffer
			vim.keymap.set('n', '<Leader>pl1', require('plugin').action, { buffer = true })
			-- set mapping for the buffer number 4
			vim.keymap.set('n', '<Leader>pl1', require('plugin').action, { buffer = 4 })
		<
		• `silent`: If set to `true`, suppress output such as error messages. >lua
			vim.keymap.set('n', '<Leader>pl1', require('plugin').action, { silent = true })
		<
		• `expr`: If set to `true`, do not execute the {rhs} but use the return value
		  as input. Special |keycodes| are converted automatically. For example, the following
		  mapping replaces <down> with <c-n> in the popupmenu only: >lua
			vim.keymap.set('c', '<down>', function()
			  if vim.fn.pumvisible() == 1 then return '<c-n>' end
			  return '<down>'
			end, { expr = true })
		<
		• `desc`: A string that is shown when listing mappings with, e.g., |:map|.
		  This is useful since Lua functions as {rhs} are otherwise only listed as
		  `Lua: <number> <source file>:<line>`. Plugins should therefore always use this
		  for mappings they create. >lua
			vim.keymap.set('n', '<Leader>pl1', require('plugin').action,
			  { desc = 'Execute action from plugin' })

	Removing mappings                                       *lua-guide-mappings-del*

		A specific mapping can be removed with |vim.keymap.del()|:
		>lua
			vim.keymap.del('n', '<Leader>ex1')
			vim.keymap.del({'n', 'c'}, '<Leader>ex2', {buffer = true})




windows:
	split:
		Horizontal:
			CTRL-W s						*CTRL-W_s*
			CTRL-W S						*CTRL-W_S*
			CTRL-W CTRL-S						*CTRL-W_CTRL-S*
			:[N]sp[lit] [++opt] [+cmd] [file]			*:sp* *:split*
			eg:- :sp nvim_notes.txt

		Vertical:
			CTRL-W CTRL-V						*CTRL-W_CTRL-V*
			CTRL-W v						*CTRL-W_v*
			:[N]vs[plit] [++opt] [+cmd] [file]			*:vs* *:vsplit*
			eg:- :vs nvim_notes.txt

		New File (horizontal) :
			CTRL-W n						*CTRL-W_n*
			CTRL-W CTRL-N						*CTRL-W_CTRL-N*
			:[N]new [++opt] [+cmd]					*:new*
			:[N]new [++opt] [+cmd] {file}
			:[N]sp[lit] [++opt] [+cmd] {file}			*:split_f*
			eg:- :sp nvim_notes.txt

		New File (vertical) :
			:[N]vne[w] [++opt] [+cmd] [file]			*:vne* *:vnew*
			eg:- :vne nvim_notes.txt
	
		Misc:
			:[N]sf[ind] [++opt] [+cmd] {file}
					Same as ":split", but search for {file} in 'path' like in
					|:find|.  Doesn't split if {file} is not found.
			eg:- :sf nvim_notes.txt

			:vert[ical] {cmd} - open cmd in vertical split like :help

    Closing a window
		:q[uit]
		:{count}q[uit]						*:count_quit*
		CTRL-W q						*CTRL-W_q*
		CTRL-W CTRL-Q						*CTRL-W_CTRL-Q*
		:q!


		:[count]fc[lose][!]				:fc :dclose
				Close [count] floating windows with the highest zindex values.
				'!' to close all floating windows.


    Moving cursor to other windows			*window-move-cursor*
		CTRL-W <Down>					*CTRL-W_<Down>*
		CTRL-W CTRL-J					*CTRL-W_CTRL-J* *CTRL-W_j*
		CTRL-W j	Move cursor to Nth window below current one.  Uses the cursor
		
		CTRL-W <Up>					*CTRL-W_<Up>*
		CTRL-W CTRL-K					*CTRL-W_CTRL-K* *CTRL-W_k*
		CTRL-W k	Move cursor to Nth window above current one.  Uses the cursor

		CTRL-W <Left>					*CTRL-W_<Left>*
		CTRL-W CTRL-H					*CTRL-W_CTRL-H*
		CTRL-W <BS>					*CTRL-W_<BS>* *CTRL-W_h*
		CTRL-W h	Move cursor to Nth window left of current one.  Uses the

		CTRL-W <Right>					*CTRL-W_<Right>*
		CTRL-W CTRL-L					*CTRL-W_CTRL-L* *CTRL-W_l*
		CTRL-W l	Move cursor to Nth window right of current one.  Uses the

		CTRL-W w					*CTRL-W_w* *CTRL-W_CTRL-W*
		CTRL-W CTRL-W	
		CTRL-W W	
		
    Window resizing:
		CTRL-W =	Make all windows (almost) equally high and wide

		:res[ize] -N					*:res* *:resize* *CTRL-W_-*
		CTRL-W -	'Decrease current window height by N' (default 1).
				If used after |:vertical|: decrease width by N.

		:res[ize] +N					*CTRL-W_+*
		CTRL-W +	Increase current window height by N (default 1).
				If used after |:vertical|: increase width by N.

		CTRL-W <	Decrease current window width by N (default 1).
		CTRL-W >	Increase current window width by N (default 1).

    Moving window around:
		CTRL-W r
		CTRL-W R
		CTRL-W x
		CTRL-W CTRL-X
		CTRL-W K	Move the current window to be at the very top, using the full
		CTRL-W J	Move the current window to be at the very bottom, using the
		CTRL-W H	Move the current window to be at the far left, using the
		CTRL-W L	Move the current window to be at the far right, using the full
		CTRL-W T	Move the current window to a new tab page.  This fails if

    Do a command in all buffers or windows			*list-repeat*
		:[range]windo {cmd}		Execute {cmd} in each |focusable| window, or only for
		:[range]bufdo[!] {cmd}	Execute {cmd} in each buffer in the buffer list or if


    Buffers:
		:files[!] [flags]				*:files*
		:buffers[!] [flags]				*:buffers* *:ls*
		:ls[!] [flags]

		Add file to buffer list	
				:bad[d] [+lnum] {fname} 	

		Delete buffer:
				:[N]bd[elete][!]			
				:bd[elete][!] [N]

		Edit buffer :
				:[N]b[uffer][!] [+cmd] [N]	
				:[N]b[uffer][!] [+cmd] {bufname}	

		Go to [N]th next buffer in buffer list.
				:[N]bn[ext][!] [+cmd] [N]	








